# Stray cats and lobotomies
## 2004/11/29 05:00

While browsing through the computer books section in Easons I came
across this book..
[You can do it: A beginners introduction to computer programming](http://www.amazon.com/exec/obidos/ASIN/0470863986/xanajavaperle-20?dev-t=D3EAQGRBM3NMZM)

Curious to see which language the author chose to inflict on the poor
neophyte reader, I picked it up and was surprised to see that the
language being taught was C++.

Ouch.

I can't imagine what it must be like learning C++ as a first
language. I imagine it would put you off programming for life.

My own first language is Basic. I also dabbled a little in Z80 machine
code (just enough to write an assembler/disassembler in Basic, and
play around with spectrum graphics) before being taught structured
programming (pascal, then Cobol, C, and finally C++, with a handful of
scripting languages, awk, rpg etc thrown in for good measure).

If I was introducing someone to programming, I would definitely choose
a gentler approach. I'd probably suggest using Perl because you can do
something useful in Perl in 5 or 6 lines of code (an equivalent C++
program might take 100 to 200 lines of code). Added to that, the kind
of person who picks up this kind of book most likely isn't going to be
programming as a full-time job, they just want to be able to do
something useful in as few lines of code as possible. 

### Stray Cats

I program in Java for a living, but most of my spare-time hacks are in
Perl, Lisp, or (increasingly) Scheme. I was
programming in C++ for a long time before switching to Java. I picked
up Perl two years ago. Elisp and Scheme are the two stray cats in my
CV. In my old age, I've become something of a
contrarian. Domain-specific languages like Emacs Lisp and GIMP's
scheme probably aren't going to land me my next job but they're
interesting languages to learn. Scheme is a dialect of Lisp, and Lisp
is like no other language I have learned to date. It looks and feels
alien - like some artifact from an extra-terrestrial intelligence far
superior to our own. I'm still not comfortable with it but I'm getting
there. What's interesting about lisp compared to other languages is
it's modularity. Other languages use declared
functions/subroutines/procedures (whatever you want to call them) as
building blocks. The blocks consist of a list of statements and have
declared boundaries. Lisp doesn't feel like that. The distinction
between statements and functions is fuzzy. In Lisp the unit of
modularity isn't the function (though there are functions) but
statements themselves. I don't claim to be even a competent Lisp
programmer, so this perception of statements as building blocks, may
just be an optical illusion, created by staring too long at
parenthesised code.

### The Lobotomy Dilemma

I've always had it in mind to Learn Python, but the more buzz that it
gets, the less I want to learn it, I already have two ubiquitous
languages (java and C++) under my belt thank you very much. Perl seems
to be in relative decline, so I find myself growing fonder of
it. People rave about Python's dynamic typing and its power and
expressiveness relative to Java and C++, but Perl is also dynamic,
powerful and expressive. The more I use Perl, the less I feel a need
to learn Python. The litmus test for any language is this. I call it
the lobotomy dilemma. Its a silly scenario and has no basis in brain
science, but it goes like this...

Imagine you are suffering from some degenerative brain disease and
need to have a lobotomy. The scans reveal that the disease is centered
in the area of the brain that coincidentally is responsible for
learning and storing programming language knowledge. The surgeon will
have to remove most of the tissue in this area, leaving only a small
portion, which coincidentally will correspond to exactly one
programming language. After the operation you will only ever be able
to program in one language. Ever. Now imagine the scanner is quite
sophisticated and can pinpoint areas of the brain responsible for each
programming language. You will get to choose which language will
remain. Which language would you choose ?

For me, this would mean losing many years of C++ and Java
expertise. Expertise that my livelihood depends on. If the choice was
a purely economic one, I would probably choose Java. If finding
employment wasn't a deciding factor, it would be Perl. If
bootstrapping my own software business, it would be Perl. In fact if
I'm feeling any way bullish at all, Perl is the language I choose
every time. 

> Lingua Franca is a pidgin, a trade language used by numerous language
> communities around the Mediterranean, to communicate with others whose
> language they did not speak. It is, in fact, the mother of all
> pidgins, seemingly in use since the Middle Ages and surviving until
> the nineteenth century, when it disappeared with hardly a trace,
> probably under the onslaught of the triumphant French language...
>  
> [A Glossary of Lingua Franca](http://www.uwm.edu/~corre/franca/edition2/lingua.2.html)

Perl is the language I'd recommend to anyone who wants to learn a
little programming, you know, just enough to get by.  I must admit, as
a C++ and Java programmer, I had a dim view of Perl before I learned
it. Now it has become my internal Lingua Franca, the pidgin code my
brain thinks in before I start typing real code. Once you learn Perl,
programming in Java or C++ just seems so unnecessarily verbose. The
gap between the pidgin code your subconscious works with, and the Java
code you eventually implement in, is that much wider. With Perl's 3
data types: scalars (equivalent to all of the java primitives),
arrays, and hashes (equivalent to java's java.util.HashMap) it makes
for a useful shorthand for my programming mind to work with. I can't
remember who it was who said that learning Lisp (even if you never use
it) will make you a better programmer. I can't vouch for that yet but
learning Perl has given me an expressive and powerful shorthand
programming language to think in (and when I have the time: to play
with too).

## Categories
Programming, Perl


